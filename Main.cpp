#include <iostream>
#include <vector>
#include <sys/stat.h>

struct Vertex {
	float x{ 0 }, y{ 0 }, z{ 0 };
};

static struct Environment {
	const char* filePath{ nullptr };
	const char* outPath{ "dump.obj" };
	unsigned long startOffset{ 0 };
	unsigned long stride{ 0 };
	unsigned long endOffset{ 0 };
	//float scale{ 0.0f };

	std::vector<Vertex> meshVertices;
} env;

#define AbortApp( ... ) printf( __VA_ARGS__ ); exit( EXIT_FAILURE )
#define Print( ... )	printf( __VA_ARGS__ )
#define Warn( ... )		printf( "WARNING: " __VA_ARGS__ )

static void SetOutPath(const char* argument) { env.outPath = argument; }
static void SetStartOffset(const char* argument) { env.startOffset = strtoul(argument, nullptr, 10); }
static void SetEndOffset(const char* argument) { env.endOffset = strtoul(argument, nullptr, 10); }
static void SetStride(const char* argument) { env.stride = strtoul(argument, nullptr, 10); }

/**
 * Parse all arguments on the command line based on the provided table.
 */
static void ParseCommandLine(int argc, char** argv) {
	struct LaunchArgument {
		const char* str;
		void(*Callback)(const char* argument);
		const char* desc;
	};
	// All possible arguments go in this table.
	static LaunchArgument launchArguments[] = {
		{ "-soff", SetStartOffset, "Set the start offset to begin reading from." },
		{ "-eoff", SetEndOffset, "Set the end offset to stop reading, otherwise reads to EOF." },
		{ "-stri", SetStride, "Number of bytes to proceed after reading XYZ." },
		{ "-outp", SetOutPath, "Set the path for the output file." },
		{ nullptr }
	};

	// If we don't have any arguments, print them out.
	if (argc <= 1) {
		Print("No arguments provided. Possible arguments are provided below.\n");
		Print("First argument is required to be a path to the file, then followed by any of the optional arguments.\n");
		LaunchArgument* opt = &launchArguments[0];
		while (opt->str != nullptr) {
			Print("   %s\t\t%s\n", opt->str, opt->desc);
			opt++;
		}
		Print("For example,\n\tbin2obj ..\\path\\myfile.whatever -soff 128\n");
		exit(EXIT_SUCCESS);
		return;
	}

	LaunchArgument* opt = &launchArguments[0];
	while (opt->str != nullptr) {
		for (int i = 0; i < argc; ++i) {
			if (strcmp(opt->str, argv[i]) != 0) {
				continue;
			}

			const char* arg = (i + 1) < argc ? argv[i + 1] : nullptr;
			opt->Callback(arg);
		}
		opt++;
	}
}

static void FileSeek(FILE* file, unsigned long numBytes, bool fromStart) {
	if (fseek(file, numBytes, fromStart ? SEEK_SET : SEEK_CUR) == 0) {
		return;
	}

	AbortApp("Failed to seek to %d!\n", numBytes);
}

#define CloseFile(FILE) if( (FILE) != nullptr ) fclose( (FILE) ); (FILE) = nullptr

int main(int argc, char** argv) {
	Print(
		"Bin2Obj by Mark \"hogsy\" Sowden <hogsy@oldtimes-software.com>\n"
		"==============================================================\n\n"
	);

	ParseCommandLine(argc, argv);

	env.filePath = argv[1];
	Print("Loading \"%s\"\n", env.filePath);

	FILE* file = fopen(env.filePath, "rb");
	if (file == nullptr) {
		AbortApp("Failed to open \"%s\"!\n", env.filePath);
	}

	FileSeek(file, env.startOffset, true);

	while (feof(file) == 0) {
		Vertex v;
		if (fread(&v, sizeof(Vertex), 1, file) != 1) {
			break;
		}
		if (isnan(v.x) || isnan(v.y) || isnan(v.z)) {
			Warn("Encountered NaN for vertex, ");
			if (isnan(v.x)) { Print("X "); v.x = 0.0f; }
			if (isnan(v.y)) { Print("Y "); v.y = 0.0f; }
			if (isnan(v.z)) { Print("Z "); v.z = 0.0f; }
			Print("- defaulting to 0.0!\n");
		}
		env.meshVertices.push_back(v);
		if (env.endOffset > 0 && ftell(file) >= env.endOffset) {
			break;
		}
		int r = fseek(file, env.stride, SEEK_CUR);
		if (env.stride > 0 && r != 0) {
			break;
		}
	}
	CloseFile(file);

	file = fopen(env.outPath, "w");
	fprintf(file, "# Generated by Bin2Obj, by Mark \"hogsy\" Sowden <hogsy@oldtimes-software.com>\n");
	for (auto& vertex : env.meshVertices) {
		fprintf(file, "v %f %f %f\n", vertex.x, vertex.y, vertex.z);
	}
	CloseFile(file);

	Print("Wrote \"%s\"!\n", env.outPath);

	return EXIT_SUCCESS;
}
